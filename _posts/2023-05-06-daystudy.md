---
layout: post
category: Go
title: Go闭包和回调
tagline: by 空谷残声
tags: 
  - 闭包 回调
---

## 闭包
闭包是指一个函数值可以引用函数体之外的变量。在 Go 中，闭包是一个函数，它包含了它自己的环境。这个环境包括了该函数要访问的任何非本地变量（也就是说，函数定义的时候不在该函数的形参列表中声明的变量）。 
 
闭包函数可以捕获其所在的环境中的变量，并且可以自由地使用这些变量，即使在其所在环境已经不存在的情况下依然可以正常工作。 
 
下面是一个使用闭包实现累加器的示例：
```
func counter() func() int {
    i := 0
    return func() int {
        i++
        return i
    }
}

func main() {
    c1 := counter()
    fmt.Println(c1()) // 输出 1
    fmt.Println(c1()) // 输出 2
    fmt.Println(c1()) // 输出 3

    c2 := counter()
    fmt.Println(c2()) // 输出 1
    fmt.Println(c2()) // 输出 2
}
```
在这个例子中，我们定义了一个函数  counter() ，它返回了一个闭包函数。该闭包函数每次被调用时都将自己内部的变量  i  加 1 并将结果返回。我们可以多次调用  counter()  函数来获取不同的闭包函数实例。由于每个实例都包含了自己的变量  i ，因此它们可以独立地计数。 
 
当我们调用  c1()  函数时，它会返回 1，然后再次调用时返回 2，再次调用时返回 3。而当我们调用  c2()  函数时，它会从零开始计数并返回 1，然后再次调用时返回 2。 
 
这个例子展示了闭包的强大功能，它允许我们定义一个通用的模板，然后在不同的上下文环境中重复使用它，而不必为每种情况都编写不同的代码。
## 回调
在Go中, 回调函数是一个函数，它被传递给另一个函数作为参数，并在函数执行过程中被调用。回调函数通常用于异步编程或事件处理程序中。 
 
下面是一个使用回调函数的示例，该示例创建一个函数  filter ，并将另一个函数  fn  作为参数传递给它。 filter  函数接受一个  int  类型的切片，并使用传递的  fn  函数对切片进行筛选。筛选规则由  fn  函数自己定义。
```
func filter(numbers []int, fn func(int) bool) []int {
    var filtered []int
    for _, n := range numbers {
        if fn(n) {
            filtered = append(filtered, n)
        }
    }
    return filtered
}

func main() {
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    even := filter(numbers, func(n int) bool {
        return n % 2 == 0
    })
    fmt.Println(even) // 输出 [2 4 6 8 10]
}
```
在这个例子中，我们定义了一个函数  filter ，它接受一个  int  类型的切片，并将另一个函数  fn  作为参数传递给它。 filter  函数使用  fn  函数对切片进行筛选，并返回一个包含所有符合条件的元素的新切片。 
 
在我们的  main  函数中，我们创建一个包含数字 1-10 的切片，并使用  filter  函数对它进行筛选，通过传递一个匿名函数作为  fn  参数来定义筛选规则。这个匿名函数返回  true  当数字是偶数时，否则返回  false 。 filter  函数使用这个函数对切片进行筛选，并返回一个包含所有偶数的新切片。 
 
回调函数是Go编程中非常常见的编程概念，尤其在处理用户输入、处理异步操作等情况下，使用回调函数可以让代码更清晰、更易于阅读和维护。








